===== TREE STRUCTURE =====
.
./dump.txt
./pyproject.toml
./README.md
./treedump
./treedump/cli.py
./treedump/__init__.py
./treedump/__pycache__
./treedump/__pycache__/cli.cpython-310.pyc
./treedump/__pycache__/__init__.cpython-310.pyc
./treedump.egg-info
./treedump.egg-info/dependency_links.txt
./treedump.egg-info/entry_points.txt
./treedump.egg-info/PKG-INFO
./treedump.egg-info/SOURCES.txt
./treedump.egg-info/top_level.txt
./tree_dump.sh

===== END TREE STRUCTURE =====

===== FILE: pyproject.toml =====
[build-system]
requires = ["setuptools>=61"]
build-backend = "setuptools.build_meta"

[project]
name = "treedump"
version = "0.1.0"
description = "Dump all text files in a directory tree into a single file"
readme = "README.md"
requires-python = ">=3.9"
authors = [
  { name="Your Name" }
]
dependencies = []

[project.scripts]
treedump = "treedump.cli:main"

===== END FILE: pyproject.toml =====

===== FILE: README.md =====
# treedump

treedump walks a directory tree and writes the contents of all text files
into a single dump.txt file.

Binary files and dump.txt itself are ignored.

## Usage

treedump

===== END FILE: README.md =====

===== FILE: treedump/cli.py =====
#!/usr/bin/env python3
import argparse
import subprocess
from pathlib import Path
import fnmatch

DEFAULT_IGNORE_PATTERNS = [
    # tooling / noise
    ".git/*",
    "__pycache__/*",
    "venv/*",
    ".venv/*",
    "node_modules/*",
    ".mypy_cache/*",
    ".pytest_cache/*",
    ".idea/*",
    ".vscode/*",

    # compiled / logs
    "*.pyc",
    "*.log",

    # secrets / credentials
    ".env",
    ".env.*",
    "*.env",
    ".secrets",
    ".secrets.*",
    "*.key",
    "*.pem",
    "*.crt",
    "*.p12",
    "*.keystore",
    "id_rsa",
    "id_ed25519",
    "*.pub",
    "credentials",
    "credentials.*",
    ".aws/*",
    ".ssh/*",
]

def run(cmd):
    return subprocess.run(
        cmd,
        capture_output=True,
        text=True,
        check=True,
    ).stdout

def is_text_file(path: Path) -> bool:
    try:
        mime = run(["file", "--mime-type", "-b", str(path)]).strip()
        return mime.startswith("text/")
    except Exception:
        return False

def load_ignore_file(path: Path):
    patterns = []
    try:
        for line in path.read_text().splitlines():
            line = line.strip()
            if not line or line.startswith("#"):
                continue
            patterns.append(line)
    except Exception:
        pass
    return patterns

def is_ignored(path: Path, patterns):
    posix_path = path.as_posix()
    for pattern in patterns:
        if fnmatch.fnmatch(posix_path, pattern) or fnmatch.fnmatch(path.name, pattern):
            return True
    return False

def main():
    parser = argparse.ArgumentParser(
        prog="treedump",
        description="Dump all text files in a directory tree into a single file.",
    )
    parser.add_argument(
        "--output",
        default="dump.txt",
        help="output file name (default: dump.txt)",
    )
    parser.add_argument(
        "--no-tree",
        action="store_true",
        help="do not include tree structure at the top of the dump",
    )
    parser.add_argument(
        "--ignore-off",
        action="store_true",
        help="disable all ignore rules (except binary files and output file)",
    )
    parser.add_argument(
        "--ignore",
        nargs="*",
        default=[],
        help="path(s) to ignore pattern files",
    )
    parser.add_argument(
        "--ignore-pattern",
        nargs="*",
        default=[],
        help="additional ignore patterns (glob syntax)",
    )

    args = parser.parse_args()

    root = Path(".").resolve()
    output_path = root / args.output
    gitignore_path = root / ".gitignore"

    # Build ignore patterns
    ignore_patterns = []

    if not args.ignore_off:
        if gitignore_path.exists():
            # Use ONLY .gitignore if present
            ignore_patterns.extend(load_ignore_file(gitignore_path))
        else:
            # Fall back to built-in defaults
            ignore_patterns.extend(DEFAULT_IGNORE_PATTERNS)

        # Add user-provided ignores
        for ignore_file in args.ignore:
            ignore_patterns.extend(load_ignore_file(Path(ignore_file)))

        ignore_patterns.extend(args.ignore_pattern)

    # Clear output
    output_path.write_text("")

    # Generate tree once
    tree_output = run(["tree", "-if", "--noreport", "."])

    # --- Tree structure ---
    if not args.no_tree:
        with output_path.open("a") as out:
            out.write("===== TREE STRUCTURE =====\n")
            out.write(tree_output)
            out.write("\n===== END TREE STRUCTURE =====\n\n")

    # --- File contents ---
    for line in tree_output.splitlines():
        path = Path(line)

        if not path.is_file():
            continue

        if path.resolve() == output_path.resolve():
            continue

        if not args.ignore_off and is_ignored(path, ignore_patterns):
            continue

        if not is_text_file(path):
            continue

        with output_path.open("a") as out:
            out.write(f"===== FILE: {path} =====\n")
            out.write(path.read_text(errors="ignore"))
            out.write(f"\n===== END FILE: {path} =====\n\n")

if __name__ == "__main__":
    main()

===== END FILE: treedump/cli.py =====

===== FILE: treedump.egg-info/entry_points.txt =====
[console_scripts]
treedump = treedump.cli:main

===== END FILE: treedump.egg-info/entry_points.txt =====

===== FILE: treedump.egg-info/PKG-INFO =====
Metadata-Version: 2.4
Name: treedump
Version: 0.1.0
Summary: Dump all text files in a directory tree into a single file
Author: Your Name
Requires-Python: >=3.9
Description-Content-Type: text/markdown

# treedump

treedump walks a directory tree and writes the contents of all text files
into a single dump.txt file.

Binary files and dump.txt itself are ignored.

## Usage

treedump

===== END FILE: treedump.egg-info/PKG-INFO =====

===== FILE: treedump.egg-info/SOURCES.txt =====
README.md
pyproject.toml
treedump/__init__.py
treedump/cli.py
treedump.egg-info/PKG-INFO
treedump.egg-info/SOURCES.txt
treedump.egg-info/dependency_links.txt
treedump.egg-info/entry_points.txt
treedump.egg-info/top_level.txt
===== END FILE: treedump.egg-info/SOURCES.txt =====

===== FILE: treedump.egg-info/top_level.txt =====
treedump

===== END FILE: treedump.egg-info/top_level.txt =====

===== FILE: tree_dump.sh =====
#!/usr/bin/env bash
set -euo pipefail

OUTPUT="dump.txt"

# Truncate output file at start
: > "$OUTPUT"

# Ensure required tools exist
command -v tree >/dev/null || { echo "tree not installed"; exit 1; }
command -v file >/dev/null || { echo "file command not installed"; exit 1; }

# Use tree to list files only, one per line
tree -if --noreport . | while read -r path; do
    # Skip directories
    [ -d "$path" ] && continue

    # Normalize path
    clean_path="${path#./}"

    # Skip the output file itself
    [ "$clean_path" = "$OUTPUT" ] && continue

    # Skip if file disappears (race safety)
    [ -f "$path" ] || continue

    # Detect MIME type
    mime=$(file --mime-type -b "$path")

    # Only allow text/*
    if [[ "$mime" != text/* ]]; then
        continue
    fi

    {
        echo "===== FILE: $clean_path ====="
        cat "$path"
        echo
        echo "===== END FILE: $clean_path ====="
        echo
    } >> "$OUTPUT"

done

===== END FILE: tree_dump.sh =====

